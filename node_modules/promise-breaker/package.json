{
  "_args": [
    [
      {
        "raw": "promise-breaker@^3.0.0",
        "scope": null,
        "escapedName": "promise-breaker",
        "name": "promise-breaker",
        "rawSpec": "^3.0.0",
        "spec": ">=3.0.0 <4.0.0",
        "type": "range"
      },
      "/home/luci/projetGit/botV2/node_modules/lol-js"
    ]
  ],
  "_from": "promise-breaker@>=3.0.0 <4.0.0",
  "_id": "promise-breaker@3.0.0",
  "_inCache": true,
  "_location": "/promise-breaker",
  "_nodeVersion": "4.2.3",
  "_npmUser": {
    "name": "jwalton",
    "email": "npm@lucid.thedreaming.org"
  },
  "_npmVersion": "2.14.7",
  "_phantomChildren": {},
  "_requested": {
    "raw": "promise-breaker@^3.0.0",
    "scope": null,
    "escapedName": "promise-breaker",
    "name": "promise-breaker",
    "rawSpec": "^3.0.0",
    "spec": ">=3.0.0 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/lol-js"
  ],
  "_resolved": "https://registry.npmjs.org/promise-breaker/-/promise-breaker-3.0.0.tgz",
  "_shasum": "bed499d1a9c35944950462baf47246fc11f19d9f",
  "_shrinkwrap": null,
  "_spec": "promise-breaker@^3.0.0",
  "_where": "/home/luci/projetGit/botV2/node_modules/lol-js",
  "author": {
    "name": "Jason Walton",
    "email": "dev@lucid.thedreaming.org",
    "url": "https://github.com/jwalton"
  },
  "bugs": {
    "url": "https://github.com/jwalton/node-promise-breaker/issues"
  },
  "dependencies": {},
  "description": "Library to help write libraries that accept both promises and callbacks.",
  "devDependencies": {
    "chai": "^3.0.0",
    "chai-as-promised": "^5.1.0",
    "coffee-script": "^1.9.3",
    "coveralls": "^2.11.2",
    "es6-promise": "^2.3.0",
    "eslint": "^1.10.3",
    "istanbul": "^0.3.15",
    "mocha": "^2.2.5"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "bed499d1a9c35944950462baf47246fc11f19d9f",
    "tarball": "https://registry.npmjs.org/promise-breaker/-/promise-breaker-3.0.0.tgz"
  },
  "gitHead": "2badc69eba7e94c7ccde5857c64b8b994f7c7598",
  "homepage": "https://github.com/jwalton/node-promise-breaker#readme",
  "keywords": [
    "promise",
    "callback",
    "library"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "jwalton",
      "email": "npm@lucid.thedreaming.org"
    }
  ],
  "name": "promise-breaker",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/jwalton/node-promise-breaker.svg)](https://travis-ci.org/jwalton/node-promise-breaker)\n[![Coverage Status](https://coveralls.io/repos/jwalton/node-promise-breaker/badge.svg)](https://coveralls.io/r/jwalton/node-promise-breaker)\n\n## What is it?\n\n`promise-breaker` makes it easy to write functions that will accept an optional callback, or return\na Promise if a callback is not provided.  You can use callbacks or Promises in your implementation,\nand callers can call with either a callback or expect a Promise.  It's a library that makes it easy\nto write libraries for others.\n\n## Installation\n\n    npm install --save promise-breaker\n\n## Requirements\n\nThis library assumes that `Promise` is a defined global variable.  If this is not the case\non your platform, you can use a polyfill:\n\n    npm install --save es6-promise\n\nThen somewhere in your node.js application:\n\n    if(!global.Promise) {\n        global.Promise = require('es6-promise').Promise;\n    }\n\nOr in your client-side app:\n\n    if(!window.Promise) {\n        window.Promise = require('es6-promise').Promise;\n    }\n\nIf you don't want to set the global, you can pass an optional Promise implementation to\n`promise-breaker`:\n\n    var MyPromise = require('es6-promise').Promise;\n    promiseBreaker = require('promise-breaker').withPromise(MyPromise);\n\n## Summary\n\nWith the growing popularity of Promises these days, if you're a library author, it's nice to\nbe able to provide your clients with a library that will take an optional callback, and if the\ncallback isn't provided, return a Promise.  If you've ever tried to do this, you know that there's\na lot of finicky boilerplate involved in every function you write.  Providing callback support is\nalso pretty important if you prefer to write your library using Promises internally.\n\n'promise-breaker' makes this really easy.  If you prefer writing in callback style:\n\n```\n// We're going to make some promises from callbacks\nvar pb = require('promise-breaker');\n\nexports.myFunc = pb.make(function(done) {\n    done(null, \"Hello World\");\n});\n```\n\nor if you prefer Promise style:\n\n\n```\n// We're going to break some promises down into callbacks\nvar pb = require('promise-breaker')\n\nexports.myFunc = pb.break(function() {\n    return Promise.resolve(\"Hello World\");\n});\n```\n\nNo matter which approach you take, users of your library can now call `myFunc(done)`, or they\ncan call `myFunc().then(...)`.\n\n## API\n\n### pb.make(fn)\n\n`make(fn)` takes a function which accepts a `callback(err, result)` as its last parameter, and\nreturns a new function which accepts an optional callback as its last parameter.  If a callback is\nprovided, this new function will behave exactly like the original function.  If the callback\nis not provided, then the new function will return a Promise.\n\nSince Promises only allow a single value to be returned, if `fn` passes more than two arguments to `callback(...)`,\nthen (as of v3.0.0) any arguments after the error will be transformed into an array and returned via the Promise as a\nsingle combined argument.  This does not affect the case where the transformed function is called with a callback.\nFor example:\n\n    var myFunc = pb.make(function(callback) {\n        // We're returning multiple values via callback\n        callback(null, \"a\", \"b\");\n    })\n\n    // Callback style\n    myFunc(function(err, a, b) {...});\n\n    // Promise style\n    myFunc()\n    .then(function(results) {\n        // Promises only let us return a single value, so we return an array.\n        var a = results[0];\n        var b = results[1];\n        ...\n    })\n    .catch(function(err) {...});\n\nNote that `pb.make()` uses `fn.length` to determine how many arguments the function expects normally,\nso `pb.make()` will not work with functions that do not explicitly define their arguments in\ntheir function declaration.\n\n### pb.break(fn)\n\n`break(fn)` is the opposite of `make(fn)`.  `fn` here is a function which returns a Promise.\n`break(fn)` will generate a new function with an extra parameter, an optional\n`callback(err, result)`.  If no callback is provided, the generated function will behave exactly\nlike the original function.  If a callback is provided, then the generated function will return\n`null`, and will pass any results that would have been returned via the Promise via the callback\ninstead.\n\nNote that `pb.break()` uses `fn.length` to determine how many arguments the function expects normally,\nso `pb.break()` will not work with functions that do not explicitly define their arguments in\ntheir function declaration.\n\n### pb.applyFn(fn, argumentCount, thisArg, args[, cb])\n\nMuch like [`Function.prototype.apply()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call),\nthis calls a function, but this lets you call into a function when you don't know whether the\nfunction is expecting a callback or is going to return a Promise.  `fn` is the function you wish\nto call, `argumentCount` is the number of arguments you expect the function to take (not including\nthe callback).  Under the hood, this will call `fn` and pass in a callback as the\n`argumentCount + 1`th parameter.  If a Promise is returned, `applyFn` will assume `fn` is Promise\nbased, otherwise `applyFn` will wait for the callback to be called.\n\nIf `cb` is provided, `applyFn` will call into `cb` with a result, otherwise `applyFn` will itself\nreturn a Promise.\n\n### pb.callFn(fn, argumentCount, thisArg[, arg1[, arg2[, ...[, cb]]]])\n\nThis is the [`Function.prototype.call()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\nequivalent of `applyFn()`.\n\nNote that if you do not specify an `argumentCount` it will default to 0.  You can use this handy shortcut:\n\n    pb.callFn(function(done) {doSomething(x, y, z, done);})\n    .then(...)\n\nto call into a callback based function from inside promise-based code.\n\n### pb.withPromise(promiseImpl)\n\nReturns a new `{make, break, applyFn, callFn}` object which uses the specified promiseImpl\nconstructor to create new Promises.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jwalton/node-promise-breaker.git"
  },
  "scripts": {
    "test": "istanbul cover _mocha && eslint ./index.js"
  },
  "version": "3.0.0"
}
