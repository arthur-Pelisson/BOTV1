{
  "_args": [
    [
      {
        "raw": "promise-tools@^1.0.1",
        "scope": null,
        "escapedName": "promise-tools",
        "name": "promise-tools",
        "rawSpec": "^1.0.1",
        "spec": ">=1.0.1 <2.0.0",
        "type": "range"
      },
      "/home/luci/projetGit/botV2/node_modules/lol-js"
    ]
  ],
  "_from": "promise-tools@>=1.0.1 <2.0.0",
  "_id": "promise-tools@1.1.0",
  "_inCache": true,
  "_location": "/promise-tools",
  "_nodeVersion": "6.10.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/promise-tools-1.1.0.tgz_1489776260929_0.18965844879858196"
  },
  "_npmUser": {
    "name": "jwalton",
    "email": "npm@lucid.thedreaming.org"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "promise-tools@^1.0.1",
    "scope": null,
    "escapedName": "promise-tools",
    "name": "promise-tools",
    "rawSpec": "^1.0.1",
    "spec": ">=1.0.1 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/lol-js"
  ],
  "_resolved": "https://registry.npmjs.org/promise-tools/-/promise-tools-1.1.0.tgz",
  "_shasum": "171447358014a202f70068e9d15d4cface0373da",
  "_shrinkwrap": null,
  "_spec": "promise-tools@^1.0.1",
  "_where": "/home/luci/projetGit/botV2/node_modules/lol-js",
  "author": {
    "name": "Jason Walton",
    "email": "dev@lucid.thedreaming.org",
    "url": "https://github.com/jwalton"
  },
  "dependencies": {},
  "description": "Tools for working with Promises",
  "devDependencies": {
    "@types/node": "6.0.52",
    "babel-cli": "^6.1.18",
    "babel-core": "^6.1.21",
    "babel-preset-es2015": "^6.1.18",
    "chai": "^3.4.1",
    "chai-as-promised": "^5.1.0",
    "coveralls": "^2.11.4",
    "es6-promise": "^3.0.2",
    "isparta": "^4.0.0",
    "mocha": "^2.3.4",
    "typescript": "2.1.4"
  },
  "directories": {},
  "dist": {
    "shasum": "171447358014a202f70068e9d15d4cface0373da",
    "tarball": "https://registry.npmjs.org/promise-tools/-/promise-tools-1.1.0.tgz"
  },
  "gitHead": "f98d10b203023689dbf4743fba6de300d5fa5431",
  "keywords": [
    "async",
    "promise",
    "q",
    "bluebird",
    "tools",
    "callback",
    "utility",
    "module"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "jwalton",
      "email": "npm@lucid.thedreaming.org"
    }
  ],
  "name": "promise-tools",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/benbria/node-promise-tools.svg?branch=master)](https://travis-ci.org/benbria/node-promise-tools)\n[![Coverage Status](https://coveralls.io/repos/benbria/node-promise-tools/badge.svg?branch=master&service=github)](https://coveralls.io/github/benbria/node-promise-tools?branch=master)\n\n## What is it?\n\nThere are a lot of nice Promise libraries out there like [bluebird](https://github.com/petkaantonov/bluebird) and\n[q](https://github.com/kriskowal/q), with many handy functions that go above and beyond the small set of standard\nfunctions defined in the ECMAScript 2015 standard. But all of these libraries make you use their implementation of\nPromise (because all of them have been around since before Promises were part of the ECMAScript standard), and\nmost of them are kind of on the big side (bluebird clocks in at almost 166k, unminified.)\n\nThe goal of `promise-tools` is to provide a small library of [async](https://github.com/caolan/async)-like functions,\nand some other handy functions, and let you use these functions on top of any Promise implementation.\n\n(Also, if you're writing a library and you want to make it easy for your callers to use either Promises or callbacks,\nbe sure to check out [promise-breaker](https://github.com/jwalton/node-promise-breaker)).\n\n## Installation\n\n    npm install --save promise-tools\n\n## Requirements\n\nThis library assumes that `Promise` is a defined global variable.  If this is not the case\non your platform, you can use a polyfill:\n\n    npm install --save es6-promise\n\nThen somewhere in your node.js application:\n\n    require('es6-promise');\n\n# API\n\n## Collections\n\n* [`map`](#map)\n\n## Utilities\n\n* [`defer`](#defer)\n* [`delay`](#delay)\n\n## Control Flow\n* [`parallel`](#parallel), `parallelLimit`\n* [`series`](#series)\n* [`timeout`](#timeout)\n* [`whilst`](#whilst), `doWhilst`\n* [`retry`](#retry)\n\n# Collections\n\n<a name=\"map\"/>\n### map(arr, iterator, limit)\n\nCalls `iterator(item, index)` for every item in `map`, which should return a Promise.  If `limit` is specified,\nthen at most `limit` calls to iterator will be started at a time (defaults to 1).  Resolves to an array of items (the\nresolved value of each promise returned by `iterator()`).  If any iterator rejects, this will reject immediately.\n\n# Utilities\n\n<a name=\"defer\"/>\n### defer()\n\nReturns a `{promise, resolve, reject}` object.  The returned `promise` will resolve or reject when `resolve` or\n`reject` are called.\n\nExample:\n\n    var deferred = promiseTools.defer();\n    deferred.then(function(result) {console.log(result);});\n    deferred.resolve(\"Hello world!\");\n\n\n<a name=\"delay\"/>\n### delay(ms)\n\nReturns a Promise which resolves after `ms` milliseconds have elapsed.  The returned Promise will never reject.\n\nExample:\n\n    console.log(\"start!\");\n    promiseTools.delay(100)\n    .then(function() {console.log(\"end!\");});\n\n\n\n\n# Control Flow\n\n<a name=\"parallel\"/>\n### parallel(tasks, limit)\n\nAlias: `parallelLimit`\n\nGiven an array of `tasks`, where each task is a function which takes no arguments and returns a Promise, executes each\ntask in parallel (which is to say that all tasks will be started at once).  If `limit` is supplied, then at most `limit`\ntasks will be started, and then as soon as any of these tasks complete a new task will be started to replace it.\n\nResolves to an array of equal length to `tasks` containing results returned by each task.  If any task rejects,\nthen this will reject immediately.\n\nExample:\n\n    promiseTools.parallel([\n        function() {return Promise.resolve(\"a\");},\n        function() {return \"b\";} // Note that raw return values are OK.\n    ]).then(function(results) {\n        // `results` will be [\"a\", \"b\"]\n    });\n\n    // Start 3 tasks, and then whenever a task completes will\n    // run another task, until all tasks are complete.\n    promiseTools.parallel(tasks, 3);\n\n\n<a name=\"series\"/>\n### series(tasks)\n\nGiven an array of `tasks`, where each task is a function which takes no arguments and returns a Promise, executes each\ntask one after another in series.  A given task will not be started until the preceding task completes.\n\nResolves to an array of equal length to `tasks` containing results returned by each task.  If any task rejects,\nthen this will reject immediately.\n\nExample:\n\n    promiseTools.series(\n        function() {return Promise.resolve(\"a\");}\n        function() {return \"b\";} // Note that raw return values are OK.\n    ).then(function(results) {\n        // `results` will be [\"a\", \"b\"]\n    });\n\n\n<a name=\"timeout\"/>\n### timeout(promise, ms)\n\nAdds a timeout to an existing Promise.\n\nResolves to the same value as `promise` if `promise` resolves within `ms` milliseconds, otherwise the returned\nPromise will reject with the error \"Timeout: Promise did not resolve within ${ms} milliseconds\".  The generated error\nwill be an instance of `promiseTools.TimeoutError`.\n\nNote that the underlying `promise` will continue to run, as there is no way to \"cancel\" a Promise in JavaScript.\n\nExample:\n\n    // Will reject if `doSomething` takes longer than 500 milliseconds.\n    promiseTools.timeout(doSomething(), 500)\n    .then(...)\n\n<a name=\"whilst\"/>\n### whilst(test, fn), doWhilst(fn, test)\n\nWhile the synchronous function `test()` returns true, `whilst` will continuously execute `fn()`.  `fn()` should return\na Promise.  `whilst` will resolve to the same value as the final call to `fn()`.  If `fn()` or `test()` throw an error,\nthen `whilst()` will reject immediately.\n\n`doWhilst()` is similar to `whilst()`, but `whilst()` might execute `fn()` zero times if `test()` returns false on the\nfirst run, where `doWhilst()` is guaranteed to call `fn()` at least once.  Note that the parameters are reversed\nbetween `whilst()` and `doWhilst()` to reflect the fact that one is \"while /test/ do /fn/\", and the other is \"do /fn/\nwhile /test/\" (and to preserve API compatibility with [async](https://github.com/caolan/async#whilst)).\n\nExample:\n\n    var count = 0;\n    promiseTools.whilst(\n        () => count < 10, /* While count is less than 10... */\n        function() {\n            /* Do this... */\n            count++;\n            return Promise.resolve(count);\n        }\n    )\n    .then(result => {\n       // result will be 10 here.\n    });\n\n<a name=\"retry\"/>\n### retry(options, fn)\n\nWill continuously call `fn` until it returns a synchronous value, doesn't throw, or returns a Promise that resolves. It will be retried `options.times`. You can pass `{times: Infinity}` to retry indefinitely. The `fn` will be passed the `lastAttempt` object which is the Error object of the last attempt.\n\nOptions: `times` (Default=5) and `interval` (Default=0). `interval` is the time between retries in milliseconds. If the `options` argument is passed as just a number, only `times` will be set.\n\nExamples:\n\n    var count = 0;\n    promiseTools.retry({times: 4, interval: 5}, function(lastAttempt) {\n        count++;\n        if (count === 2) Promise.resolve(true);\n        else Promise.reject(new Error('boom'));\n    })\n    .then(function(result) {\n       // result will be `true` here.\n    });\n\n    ---------------------------------------------\n\n    var count = 0;\n    promiseTools.retry(1, function(lastAttempt) {\n        count++;\n        if (count === 2) Promise.resolve(true);\n        else Promise.reject(new Error('boom'));\n    })\n    .then(function(result) {\n       // will not resolve.\n    })\n    .catch(function(err) {\n        // err.message should be `boom` here.\n    });\n",
  "readmeFilename": "README.md",
  "scripts": {
    "clean": "rm -rf lib coverage",
    "coverage": "babel-node node_modules/isparta/bin/isparta cover node_modules/mocha/bin/_mocha",
    "prepublish": "babel -d lib src",
    "quicktest": "mocha",
    "test": "mocha --compilers js:babel-core/register"
  },
  "types": "./index.d.ts",
  "version": "1.1.0"
}
